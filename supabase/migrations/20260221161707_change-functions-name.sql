drop policy "Enable read access for all users" on "public"."class_performances_schedule";

revoke delete on table "public"."class_performances_schedule" from "anon";

revoke insert on table "public"."class_performances_schedule" from "anon";

revoke references on table "public"."class_performances_schedule" from "anon";

revoke select on table "public"."class_performances_schedule" from "anon";

revoke trigger on table "public"."class_performances_schedule" from "anon";

revoke truncate on table "public"."class_performances_schedule" from "anon";

revoke update on table "public"."class_performances_schedule" from "anon";

revoke delete on table "public"."class_performances_schedule" from "authenticated";

revoke insert on table "public"."class_performances_schedule" from "authenticated";

revoke references on table "public"."class_performances_schedule" from "authenticated";

revoke select on table "public"."class_performances_schedule" from "authenticated";

revoke trigger on table "public"."class_performances_schedule" from "authenticated";

revoke truncate on table "public"."class_performances_schedule" from "authenticated";

revoke update on table "public"."class_performances_schedule" from "authenticated";

revoke delete on table "public"."class_performances_schedule" from "service_role";

revoke insert on table "public"."class_performances_schedule" from "service_role";

revoke references on table "public"."class_performances_schedule" from "service_role";

revoke select on table "public"."class_performances_schedule" from "service_role";

revoke trigger on table "public"."class_performances_schedule" from "service_role";

revoke truncate on table "public"."class_performances_schedule" from "service_role";

revoke update on table "public"."class_performances_schedule" from "service_role";

alter table "public"."class_tickets" drop constraint "class_tickets_round_id_fkey";

alter table "public"."class_performances_schedule" drop constraint "performances_schedule_pkey";

drop index if exists "public"."performances_schedule_pkey";

drop table "public"."class_performances_schedule";


  create table "public"."performances_schedule" (
    "created_at" timestamp with time zone not null default now(),
    "start_at" timestamp with time zone not null,
    "id" smallint generated by default as identity not null,
    "is_active" boolean not null default true,
    "round_name" text not null
      );


alter table "public"."performances_schedule" enable row level security;

CREATE UNIQUE INDEX performances_schedule_pkey ON public.performances_schedule USING btree (id);

alter table "public"."performances_schedule" add constraint "performances_schedule_pkey" PRIMARY KEY using index "performances_schedule_pkey";

alter table "public"."class_tickets" add constraint "class_tickets_round_id_fkey" FOREIGN KEY (round_id) REFERENCES public.performances_schedule(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."class_tickets" validate constraint "class_tickets_round_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.issue_class_tickets_with_codes(p_user_id uuid, p_ticket_type_id smallint, p_relationship_id smallint, p_performance_id smallint, p_schedule_id smallint, p_issue_count integer, p_codes text[], p_signatures text[])
 RETURNS TABLE(code text, signature text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$declare
  v_affiliation smallint;
  v_role text;
  v_max_tickets smallint;
  v_junior_release_open boolean;
  v_existing_user_tickets integer;
  v_total_capacity smallint;
  v_junior_capacity smallint;
  v_general_count integer;
  v_junior_count integer;
  v_remaining_general integer;
  v_remaining_junior integer;
  v_required_remaining integer;
begin
  if p_user_id is null then
    raise exception 'user is required';
  end if;

  if p_issue_count is null or p_issue_count <= 0 then
    raise exception 'issue_count must be positive';
  end if;

  if p_codes is null or p_signatures is null then
    raise exception 'codes/signatures are required';
  end if;

  if array_length(p_codes, 1) is distinct from p_issue_count
     or array_length(p_signatures, 1) is distinct from p_issue_count then
    raise exception 'codes/signatures length mismatch';
  end if;

  perform pg_advisory_xact_lock(p_performance_id::integer, p_schedule_id::integer);

  select affiliation, role
  into v_affiliation, v_role
  from public.users
  where id = p_user_id
  limit 1
  for update;

  if not found or v_role <> 'student' then
    raise exception 'only students can issue tickets';
  end if;

  select max_tickets_per_user, junior_release_open
  into v_max_tickets, v_junior_release_open
  from public.configs
  order by id asc
  limit 1
  for update;

  if v_max_tickets is null then
    raise exception 'config not found';
  end if;

  if p_issue_count > v_max_tickets then
    raise exception 'issue count exceeds max_tickets_per_user';
  end if;

  select count(*)::int
  into v_existing_user_tickets
  from public.tickets
  where user_id = p_user_id
    and status = 'valid';

  if v_existing_user_tickets + p_issue_count > v_max_tickets then
    raise exception 'ticket limit exceeded';
  end if;

  select total_capacity, junior_capacity
  into v_total_capacity, v_junior_capacity
  from public.class_performances
  where id = p_performance_id
  limit 1
  for update;

  if not found then
    raise exception 'performance not found';
  end if;

  perform 1
  from public.performances_schedule
  where id = p_schedule_id
    and is_active = true
  limit 1
  for update;

  if not found then
    raise exception 'schedule not found';
  end if;

  select
    count(*) filter (where t.ticket_type in (1, 3) and t.status = 'valid')::int,
    count(*) filter (where t.ticket_type = 2 and t.status = 'valid')::int
  into v_general_count, v_junior_count
  from public.class_tickets ct
  join public.tickets t on t.id = ct.id
  where ct.class_id = p_performance_id
    and ct.round_id = p_schedule_id;

  if v_junior_release_open then
    v_remaining_general := v_total_capacity - v_general_count - v_junior_count;
    v_remaining_junior := 0;
  else
    v_remaining_general := v_total_capacity - v_junior_capacity - v_general_count;
    v_remaining_junior := v_junior_capacity - v_junior_count;
  end if;

  if p_ticket_type_id = 2 then
    v_required_remaining := v_remaining_junior;
  else
    v_required_remaining := v_remaining_general;
  end if;

  if v_required_remaining < p_issue_count then
    raise exception 'not enough remaining seats';
  end if;

  return query
  with input_rows as (
    select
      ordinality,
      p_codes[ordinality] as input_code,
      p_signatures[ordinality] as input_signature
    from generate_subscripts(p_codes, 1) as ordinality
  ), inserted_tickets as (
    insert into public.tickets as t (
      id,
      code,
      signature,
      ticket_type,
      status,
      user_id,
      relationship
    )
    select
      gen_random_uuid(),
      input_rows.input_code,
      input_rows.input_signature,
      p_ticket_type_id,
      'valid'::public.ticket_status,
      p_user_id,
      p_relationship_id
    from input_rows
    returning t.id as ticket_id, t.code as ticket_code, t.signature as ticket_signature
  ), inserted_class_tickets as (
    insert into public.class_tickets (id, class_id, round_id)
    select inserted_tickets.ticket_id, p_performance_id, p_schedule_id
    from inserted_tickets
    returning id
  )
  select inserted_tickets.ticket_code as code, inserted_tickets.ticket_signature as signature
  from inserted_tickets
  order by inserted_tickets.ticket_code;
end;$function$
;

grant delete on table "public"."performances_schedule" to "anon";

grant insert on table "public"."performances_schedule" to "anon";

grant references on table "public"."performances_schedule" to "anon";

grant select on table "public"."performances_schedule" to "anon";

grant trigger on table "public"."performances_schedule" to "anon";

grant truncate on table "public"."performances_schedule" to "anon";

grant update on table "public"."performances_schedule" to "anon";

grant delete on table "public"."performances_schedule" to "authenticated";

grant insert on table "public"."performances_schedule" to "authenticated";

grant references on table "public"."performances_schedule" to "authenticated";

grant select on table "public"."performances_schedule" to "authenticated";

grant trigger on table "public"."performances_schedule" to "authenticated";

grant truncate on table "public"."performances_schedule" to "authenticated";

grant update on table "public"."performances_schedule" to "authenticated";

grant delete on table "public"."performances_schedule" to "service_role";

grant insert on table "public"."performances_schedule" to "service_role";

grant references on table "public"."performances_schedule" to "service_role";

grant select on table "public"."performances_schedule" to "service_role";

grant trigger on table "public"."performances_schedule" to "service_role";

grant truncate on table "public"."performances_schedule" to "service_role";

grant update on table "public"."performances_schedule" to "service_role";


  create policy "Enable read access for all users"
  on "public"."performances_schedule"
  as permissive
  for select
  to public
using (true);



